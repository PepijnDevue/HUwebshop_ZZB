<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>huw API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>huw</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from flask import Flask, request, session, render_template, redirect, url_for, g
import random, os, json, urllib.parse, requests
from pymongo import MongoClient
from dotenv import load_dotenv
from bson.objectid import ObjectId

# The secret key used for session encryption is randomly generated every time
# the server is started up. This means all session data (including the 
# shopping cart) is erased between server instances.
app = Flask(__name__)
app.secret_key = os.urandom(16)

class HUWebshop(object):
    &#34;&#34;&#34; This class combines all logic behind the HU Example Webshop project. 
    Note that all rendering is performed within the templates themselves.&#34;&#34;&#34;

    app = None
    client = None
    database = None

    envvals = [&#34;MONGODBUSER&#34;,&#34;MONGODBPASSWORD&#34;,&#34;MONGODBSERVER&#34;]
    dbstring = &#39;mongodb+srv://{0}:{1}@{2}/test?retryWrites=true&amp;w=majority&#39;
    recseraddress = &#34;http://127.0.0.1:5001&#34;

    categoryindex = None
    catlevels = [&#34;category&#34;,&#34;sub_category&#34;,&#34;sub_sub_category&#34;,&#34;sub_sub_sub_category&#34;]
    catencode = {}
    catdecode = {}
    mainmenucount = 8
    mainmenuitems = None

    paginationcounts = [8, 16, 32, 0]

    productfields = [&#34;name&#34;, &#34;price.selling_price&#34;, &#34;properties.discount&#34;, &#34;images&#34;]

    recommendationtypes = {&#39;popular&#39;:&#34;Anderen kochten ook&#34;,&#39;similar&#39;:&#34;Soortgelijke producten&#34;,&#39;combination&#39;:&#39;Combineert goed met&#39;,&#39;behaviour&#39;:&#39;Passend bij uw gedrag&#39;,&#39;personal&#39;:&#39;Persoonlijk aanbevolen&#39;}

    &#34;&#34;&#34; ..:: Initialization and Category Index Functions ::.. &#34;&#34;&#34;

    def __init__(self, app):
        &#34;&#34;&#34; Within this constructor, we establish a connection with the database
        and perform necessary setup of the database (if applicable) and menu.&#34;&#34;&#34;
        self.app = app

        # Depending on whether environment variables have been set, we connect
        # to a local or remote instance of MongoDB.
        load_dotenv()
        if os.getenv(self.envvals[0]) is not None:
            self.envvals = list(map(lambda x: str(os.getenv(x)), self.envvals))
            self.client = MongoClient(self.dbstring.format(*self.envvals))
            self.recseraddress = os.getenv(&#34;RECOMADDRESS&#34;)
        else:
            self.client = MongoClient()
        self.database = self.client.huwebshop 

        # Once we have a connection to the database, we check to see whether it
        # has a category index prepared; if not, we have a function to make it.
        if &#34;categoryindex&#34; not in self.database.list_collection_names() or self.database.categoryindex.count_documents({}) == 0:
            self.createcategoryindex()

        # We retrieve the categoryindex from the database when it is set.
        self.categoryindex = self.database.categoryindex.find_one({}, {&#39;_id&#39; : 0})

        # In order to save time in future, we flatten the category index once,
        # and translate all values to and from an encoded, URL-friendly, legible
        # format.
        catlist = self.flattendict(self.categoryindex)
        for cat in catlist:
            enc_cat = self.encodecategory(cat)
            self.catencode[cat] = enc_cat
            self.catdecode[enc_cat] = cat

        # Since the main menu can&#39;t show all the category options at once in a
        # legible manner, we choose to display a set number with the greatest 
        # number of associated products.
        countlist = list(map(lambda x, y: (y[&#39;_count&#39;], x), self.categoryindex.keys(), self.categoryindex.values()))
        countlist.sort(reverse=True)
        self.mainmenuitems = [x[1] for x in countlist[0:self.mainmenucount]]

        # Finally, we here attach URL rules to all pages we wish to render, to
        # make the code self-contained; although the more common decorators do
        # the same thing, we wish to have this class contain as much logic as
        # possible.
        self.app.before_request(self.checksession)
        self.app.add_url_rule(&#39;/&#39;, &#39;index&#39;, self.renderpackettemplate)
        self.app.add_url_rule(&#39;/producten/&#39;, &#39;producten-0&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&#39;, &#39;producten-1&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&#39;, &#39;producten-2&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&#39;, &#39;producten-3&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;int:page&gt;/&#39;, &#39;producten-4&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;int:page&gt;/&#39;, &#39;producten-5&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;int:page&gt;/&#39;, &#39;producten-6&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&lt;int:page&gt;/&#39;, &#39;producten-7&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&lt;cat4&gt;/&lt;int:page&gt;/&#39;, &#39;producten-8&#39;, self.productpage)
        self.app.add_url_rule(&#39;/productdetail/&lt;productid&gt;/&#39;, &#39;productdetail&#39;, self.productdetail)
        self.app.add_url_rule(&#39;/winkelmand/&#39;, &#39;winkelmand&#39;, self.shoppingcart)
        self.app.add_url_rule(&#39;/categorieoverzicht/&#39;, &#39;categorieoverzicht&#39;, self.categoryoverview)
        self.app.add_url_rule(&#39;/change-profile-id&#39;, &#39;profielid&#39;, self.changeprofileid, methods=[&#39;POST&#39;])
        self.app.add_url_rule(&#39;/add-to-shopping-cart&#39;, &#39;toevoegenaanwinkelmand&#39;, self.addtoshoppingcart, methods=[&#39;POST&#39;])
        self.app.add_url_rule(&#39;/producten/pagination-change&#39;, &#39;aantalperpaginaaanpassen&#39;, self.changepaginationcount, methods=[&#39;POST&#39;])

    def createcategoryindex(self):
        &#34;&#34;&#34; Within this function, we compose a nested dictionary of all 
        categories that occur within the database&#39;s products collection, and 
        save it to the categoryindex collection. &#34;&#34;&#34;
        pcatentries = self.database.products.find({},self.catlevels)
        index = {}
        for entry in pcatentries:
            self.reccatindex(index, entry, 0, len(self.catlevels)-1)
        for k, v in index.items():
            self.reccatcount(k, v, 0, len(self.catlevels)-1)
        self.database.categoryindex.insert_one(index)

    def reccatindex(self,d,e,l,m):
        &#34;&#34;&#34; This subfunction of createcategoryindex() sets up the base structure
        (tree) of the categories and subcategories, leaving leaves as empty 
        dicts.&#34;&#34;&#34;
        if l &gt; m:
            return
        t = self.catlevels[l]
        if t in e and e[t] is not None and type(e[t]) != list and e[t] not in d:
            d[e[t]] = {}
        if t in e and e[t] is not None and type(e[t]) != list and e[t] in d:
            self.reccatindex(d[e[t]],e,l+1,m)

    def reccatcount(self,k,v,l,m):
        &#34;&#34;&#34; This subfunction of createcategoryindex() adds the number of 
        documents associated with any (sub)category to its dictionary as the
        _count property. &#34;&#34;&#34;
        if l &gt; m:
            return
        if isinstance(v, dict):
            for k2, v2 in v.items():
                self.reccatcount(k2, v2, l+1, m)
        if k[:1] != &#34;_&#34;:
            v[&#39;_count&#39;] = self.database.products.count_documents({self.catlevels[l]:k})

    &#34;&#34;&#34; ..:: Helper Functions ::.. &#34;&#34;&#34;

    def flattendict(self,d,s=[]):
        &#34;&#34;&#34; This helper function provides a list of all keys that exist within a
        nested dictionary. &#34;&#34;&#34;
        for k, v in d.items():
            # Note that the condition below prevents the _count property from
            # being added to the list over and over again.
            if k[:1] != &#34;_&#34;:
                s.append(k)
                if isinstance(v, dict) and v:
                    s = self.flattendict(v, s)
        return s

    def encodecategory(self,c):
        &#34;&#34;&#34; This helper function encodes any category name into a URL-friendly
        string, making sensible and human-readable substitutions. &#34;&#34;&#34;
        c = c.lower()
        c = c.replace(&#34; &#34;,&#34;-&#34;)
        c = c.replace(&#34;,&#34;,&#34;&#34;)
        c = c.replace(&#34;&#39;&#34;,&#34;&#34;)
        c = c.replace(&#34;&amp;&#34;,&#34;en&#34;)
        c = c.replace(&#34;ë&#34;,&#34;e&#34;)
        c = c.replace(&#34;=&#34;,&#34;-is-&#34;)
        c = c.replace(&#34;%&#34;,&#34;-procent-&#34;)
        c = c.replace(&#34;--&#34;,&#34;-&#34;)
        c = urllib.parse.quote(c)
        return c

    def prepproduct(self,p):
        &#34;&#34;&#34; This helper function flattens and rationalizes the values retrieved
        for a product block element. &#34;&#34;&#34;
        r = {}
        r[&#39;name&#39;] = p[&#39;name&#39;]
        r[&#39;price&#39;] = p[&#39;price&#39;][&#39;selling_price&#39;]
        r[&#39;price&#39;] = str(r[&#39;price&#39;])[0:-2]+&#34;,-&#34; if r[&#39;price&#39;] % 100 == 0 else str(r[&#39;price&#39;])[0:-2]+&#34;,&#34;+str(r[&#39;price&#39;])[-2:]
        if r[&#39;price&#39;][0:1] == &#34;,&#34;:
            r[&#39;price&#39;] = &#34;0&#34;+r[&#39;price&#39;]
        if p[&#39;properties&#39;][&#39;discount&#39;] is not None:
            r[&#39;discount&#39;] = p[&#39;properties&#39;][&#39;discount&#39;] 
        r[&#39;smallimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
        r[&#39;bigimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
        r[&#39;id&#39;] = p[&#39;_id&#39;]
        return r

    def shoppingcartcount(self):
        &#34;&#34;&#34; This function returns the number of items in the shopping cart. &#34;&#34;&#34;
        return sum(list(map(lambda x: x[1], session[&#39;shopping_cart&#39;])))

    &#34;&#34;&#34; ..:: Session and Templating Functions ::.. &#34;&#34;&#34;

    def checksession(self):
        &#34;&#34;&#34; This function sets certain generally used session variables when
        those have not yet been set. This executes before every request, but
        will most likely only make changes once. &#34;&#34;&#34;
        if (&#39;session_valid&#39; not in session) or (session[&#39;session_valid&#39;] != 1):
            session[&#39;shopping_cart&#39;] = []
            session[&#39;items_per_page&#39;] = self.paginationcounts[0]
            session[&#39;session_id&#39;] = self.database.sessions.find_one({})[&#39;buid&#39;][0]
            session[&#39;profile_id&#39;] = str(self.database.profiles.find_one({})[&#39;_id&#39;])
            session[&#39;session_valid&#39;] = 1

    def renderpackettemplate(self, template=&#34;homepage.html&#34;, packet={}):
        &#34;&#34;&#34; This helper function adds all generally important variables to the
        packet sent to the templating engine, then calling upon Flask to 
        perform the actual render. &#34;&#34;&#34;
        packet[&#39;categoryindex&#39;] = self.categoryindex
        packet[&#39;mainmenulist&#39;] = self.mainmenuitems
        packet[&#39;categories_encode&#39;] = self.catencode
        packet[&#39;categories_decode&#39;] = self.catdecode
        packet[&#39;paginationcounts&#39;] = self.paginationcounts
        packet[&#39;items_per_page&#39;] = session[&#39;items_per_page&#39;]
        packet[&#39;session_id&#39;] = session[&#39;session_id&#39;]
        packet[&#39;profile_id&#39;] = session[&#39;profile_id&#39;]
        packet[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
        packet[&#39;shopping_cart_count&#39;] = self.shoppingcartcount()
        return render_template(template, packet=packet)

    &#34;&#34;&#34; ..:: Recommendation Functions ::.. &#34;&#34;&#34;

    def recommendations(self, count):
        &#34;&#34;&#34; This function returns the recommendations from the provided page
        and context, by sending a request to the designated recommendation
        service. &#34;&#34;&#34;
        resp = requests.get(self.recseraddress+&#34;/&#34;+session[&#39;profile_id&#39;]+&#34;/&#34;+str(count))
        if resp.status_code == 200:
            recs = eval(resp.content.decode())
            queryfilter = {&#34;_id&#34;: {&#34;$in&#34;: recs}}
            querycursor = self.database.products.find(queryfilter, self.productfields)
            resultlist = list(map(self.prepproduct, list(querycursor)))
            return resultlist
        return []

    &#34;&#34;&#34; ..:: Full Page Endpoints ::.. &#34;&#34;&#34;

    def productpage(self, cat1=None, cat2=None, cat3=None, cat4=None, page=1):
        &#34;&#34;&#34; This function renders the product page template with the products it
        can retrieve from the database, based on the URL path provided. &#34;&#34;&#34;
        catlist = [cat1, cat2, cat3, cat4]
        queryfilter = {}
        nononescats = []
        for k, v in enumerate(catlist):
            if v is not None:
                queryfilter[self.catlevels[k]] = self.catdecode[v]
                nononescats.append(v)
        querycursor = self.database.products.find(queryfilter, self.productfields)
        prodcount = self.database.products.count_documents(queryfilter)
        skipindex = session[&#39;items_per_page&#39;]*(page-1)
        querycursor.skip(skipindex)
        querycursor.limit(session[&#39;items_per_page&#39;])
        prodlist = list(map(self.prepproduct, list(querycursor)))
        if len(nononescats) &gt; 1:
            pagepath = &#34;/producten/&#34;+(&#34;/&#34;.join(nononescats))+&#34;/&#34;
        else:
            pagepath = &#34;/producten/&#34;
        return self.renderpackettemplate(&#39;products.html&#39;, {&#39;products&#39;: prodlist, \
            &#39;productcount&#39;: prodcount, \
            &#39;pstart&#39;: skipindex + 1, \
            &#39;pend&#39;: skipindex + session[&#39;items_per_page&#39;] if session[&#39;items_per_page&#39;] &gt; 0 else prodcount, \
            &#39;prevpage&#39;: pagepath+str(page-1) if (page &gt; 1) else False, \
            &#39;nextpage&#39;: pagepath+str(page+1) if (session[&#39;items_per_page&#39;]*page &lt; prodcount) else False, \
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[0],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[0]\
            })

    def productdetail(self, productid):
        &#34;&#34;&#34; This function renders the product detail page based on the product
        id provided. &#34;&#34;&#34;
        product = self.database.products.find_one({&#34;_id&#34;:str(productid)})
        return self.renderpackettemplate(&#39;productdetail.html&#39;, {&#39;product&#39;:product,\
            &#39;prepproduct&#39;:self.prepproduct(product),\
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[1],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[1]})

    def shoppingcart(self):
        &#34;&#34;&#34; This function renders the shopping cart for the user.&#34;&#34;&#34;
        i = []
        for tup in session[&#39;shopping_cart&#39;]:
            product = self.prepproduct(self.database.products.find_one({&#34;_id&#34;:str(tup[0])}))
            product[&#34;itemcount&#34;] = tup[1]
            i.append(product)
        return self.renderpackettemplate(&#39;shoppingcart.html&#39;,{&#39;itemsincart&#39;:i,\
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[2],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[2]})

    def categoryoverview(self):
        &#34;&#34;&#34; This subpage shows all top-level categories in its main menu. &#34;&#34;&#34;
        return self.renderpackettemplate(&#39;categoryoverview.html&#39;)

    &#34;&#34;&#34; ..:: Dynamic AJAX Endpoints ::.. &#34;&#34;&#34;

    def changeprofileid(self):
        &#34;&#34;&#34; This function checks whether the provided session ID actually exists
        and stores it in the session if it does. &#34;&#34;&#34;
        try:
            newprofileid = request.form.get(&#39;profile_id&#39;)
            profidexists = self.database.profiles.find_one({&#39;_id&#39;: ObjectId(newprofileid)})
            if profidexists:
                session[&#39;profile_id&#39;] = newprofileid
                return &#39;{&#34;success&#34;:true}&#39;
            return &#39;{&#34;success&#34;:false}&#39;
        except:
            return &#39;{&#34;success&#34;:false}&#39;

    def addtoshoppingcart(self):
        &#34;&#34;&#34; This function adds one to the shopping cart. &#34;&#34;&#34;
        productid = request.form.get(&#39;product_id&#39;)
        cartids = list(map(lambda x: x[0], session[&#39;shopping_cart&#39;]))
        if productid in cartids:
            ind = cartids.index(productid)
            session[&#39;shopping_cart&#39;][ind] = (session[&#39;shopping_cart&#39;][ind][0], session[&#39;shopping_cart&#39;][ind][1]+1)
        else:
            session[&#39;shopping_cart&#39;].append((productid, 1))
        session[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
        return &#39;{&#34;success&#34;:true, &#34;itemcount&#34;:&#39;+str(self.shoppingcartcount())+&#39;}&#39;

    def changepaginationcount(self):
        &#34;&#34;&#34; This function changes the number of items displayed on the provided 
        page. &#34;&#34;&#34;
        session[&#39;items_per_page&#39;] = int(request.form.get(&#39;items_per_page&#39;))
        # TODO: add method that returns the exact URL the user should be 
        # returned to, including offset
        return &#39;{&#34;success&#34;:true, &#34;refurl&#34;:&#34;&#39;+request.form.get(&#39;refurl&#39;)+&#39;&#34;}&#39;

    # TODO: add @app.errorhandler(404) and @app.errorhandler(405)

huw = HUWebshop(app)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="huw.HUWebshop"><code class="flex name class">
<span>class <span class="ident">HUWebshop</span></span>
<span>(</span><span>app)</span>
</code></dt>
<dd>
<section class="desc"><p>This class combines all logic behind the HU Example Webshop project.
Note that all rendering is performed within the templates themselves.</p>
<p>Within this constructor, we establish a connection with the database
and perform necessary setup of the database (if applicable) and menu.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class HUWebshop(object):
    &#34;&#34;&#34; This class combines all logic behind the HU Example Webshop project. 
    Note that all rendering is performed within the templates themselves.&#34;&#34;&#34;

    app = None
    client = None
    database = None

    envvals = [&#34;MONGODBUSER&#34;,&#34;MONGODBPASSWORD&#34;,&#34;MONGODBSERVER&#34;]
    dbstring = &#39;mongodb+srv://{0}:{1}@{2}/test?retryWrites=true&amp;w=majority&#39;
    recseraddress = &#34;http://127.0.0.1:5001&#34;

    categoryindex = None
    catlevels = [&#34;category&#34;,&#34;sub_category&#34;,&#34;sub_sub_category&#34;,&#34;sub_sub_sub_category&#34;]
    catencode = {}
    catdecode = {}
    mainmenucount = 8
    mainmenuitems = None

    paginationcounts = [8, 16, 32, 0]

    productfields = [&#34;name&#34;, &#34;price.selling_price&#34;, &#34;properties.discount&#34;, &#34;images&#34;]

    recommendationtypes = {&#39;popular&#39;:&#34;Anderen kochten ook&#34;,&#39;similar&#39;:&#34;Soortgelijke producten&#34;,&#39;combination&#39;:&#39;Combineert goed met&#39;,&#39;behaviour&#39;:&#39;Passend bij uw gedrag&#39;,&#39;personal&#39;:&#39;Persoonlijk aanbevolen&#39;}

    &#34;&#34;&#34; ..:: Initialization and Category Index Functions ::.. &#34;&#34;&#34;

    def __init__(self, app):
        &#34;&#34;&#34; Within this constructor, we establish a connection with the database
        and perform necessary setup of the database (if applicable) and menu.&#34;&#34;&#34;
        self.app = app

        # Depending on whether environment variables have been set, we connect
        # to a local or remote instance of MongoDB.
        load_dotenv()
        if os.getenv(self.envvals[0]) is not None:
            self.envvals = list(map(lambda x: str(os.getenv(x)), self.envvals))
            self.client = MongoClient(self.dbstring.format(*self.envvals))
            self.recseraddress = os.getenv(&#34;RECOMADDRESS&#34;)
        else:
            self.client = MongoClient()
        self.database = self.client.huwebshop 

        # Once we have a connection to the database, we check to see whether it
        # has a category index prepared; if not, we have a function to make it.
        if &#34;categoryindex&#34; not in self.database.list_collection_names() or self.database.categoryindex.count_documents({}) == 0:
            self.createcategoryindex()

        # We retrieve the categoryindex from the database when it is set.
        self.categoryindex = self.database.categoryindex.find_one({}, {&#39;_id&#39; : 0})

        # In order to save time in future, we flatten the category index once,
        # and translate all values to and from an encoded, URL-friendly, legible
        # format.
        catlist = self.flattendict(self.categoryindex)
        for cat in catlist:
            enc_cat = self.encodecategory(cat)
            self.catencode[cat] = enc_cat
            self.catdecode[enc_cat] = cat

        # Since the main menu can&#39;t show all the category options at once in a
        # legible manner, we choose to display a set number with the greatest 
        # number of associated products.
        countlist = list(map(lambda x, y: (y[&#39;_count&#39;], x), self.categoryindex.keys(), self.categoryindex.values()))
        countlist.sort(reverse=True)
        self.mainmenuitems = [x[1] for x in countlist[0:self.mainmenucount]]

        # Finally, we here attach URL rules to all pages we wish to render, to
        # make the code self-contained; although the more common decorators do
        # the same thing, we wish to have this class contain as much logic as
        # possible.
        self.app.before_request(self.checksession)
        self.app.add_url_rule(&#39;/&#39;, &#39;index&#39;, self.renderpackettemplate)
        self.app.add_url_rule(&#39;/producten/&#39;, &#39;producten-0&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&#39;, &#39;producten-1&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&#39;, &#39;producten-2&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&#39;, &#39;producten-3&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;int:page&gt;/&#39;, &#39;producten-4&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;int:page&gt;/&#39;, &#39;producten-5&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;int:page&gt;/&#39;, &#39;producten-6&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&lt;int:page&gt;/&#39;, &#39;producten-7&#39;, self.productpage)
        self.app.add_url_rule(&#39;/producten/&lt;cat1&gt;/&lt;cat2&gt;/&lt;cat3&gt;/&lt;cat4&gt;/&lt;int:page&gt;/&#39;, &#39;producten-8&#39;, self.productpage)
        self.app.add_url_rule(&#39;/productdetail/&lt;productid&gt;/&#39;, &#39;productdetail&#39;, self.productdetail)
        self.app.add_url_rule(&#39;/winkelmand/&#39;, &#39;winkelmand&#39;, self.shoppingcart)
        self.app.add_url_rule(&#39;/categorieoverzicht/&#39;, &#39;categorieoverzicht&#39;, self.categoryoverview)
        self.app.add_url_rule(&#39;/change-profile-id&#39;, &#39;profielid&#39;, self.changeprofileid, methods=[&#39;POST&#39;])
        self.app.add_url_rule(&#39;/add-to-shopping-cart&#39;, &#39;toevoegenaanwinkelmand&#39;, self.addtoshoppingcart, methods=[&#39;POST&#39;])
        self.app.add_url_rule(&#39;/producten/pagination-change&#39;, &#39;aantalperpaginaaanpassen&#39;, self.changepaginationcount, methods=[&#39;POST&#39;])

    def createcategoryindex(self):
        &#34;&#34;&#34; Within this function, we compose a nested dictionary of all 
        categories that occur within the database&#39;s products collection, and 
        save it to the categoryindex collection. &#34;&#34;&#34;
        pcatentries = self.database.products.find({},self.catlevels)
        index = {}
        for entry in pcatentries:
            self.reccatindex(index, entry, 0, len(self.catlevels)-1)
        for k, v in index.items():
            self.reccatcount(k, v, 0, len(self.catlevels)-1)
        self.database.categoryindex.insert_one(index)

    def reccatindex(self,d,e,l,m):
        &#34;&#34;&#34; This subfunction of createcategoryindex() sets up the base structure
        (tree) of the categories and subcategories, leaving leaves as empty 
        dicts.&#34;&#34;&#34;
        if l &gt; m:
            return
        t = self.catlevels[l]
        if t in e and e[t] is not None and type(e[t]) != list and e[t] not in d:
            d[e[t]] = {}
        if t in e and e[t] is not None and type(e[t]) != list and e[t] in d:
            self.reccatindex(d[e[t]],e,l+1,m)

    def reccatcount(self,k,v,l,m):
        &#34;&#34;&#34; This subfunction of createcategoryindex() adds the number of 
        documents associated with any (sub)category to its dictionary as the
        _count property. &#34;&#34;&#34;
        if l &gt; m:
            return
        if isinstance(v, dict):
            for k2, v2 in v.items():
                self.reccatcount(k2, v2, l+1, m)
        if k[:1] != &#34;_&#34;:
            v[&#39;_count&#39;] = self.database.products.count_documents({self.catlevels[l]:k})

    &#34;&#34;&#34; ..:: Helper Functions ::.. &#34;&#34;&#34;

    def flattendict(self,d,s=[]):
        &#34;&#34;&#34; This helper function provides a list of all keys that exist within a
        nested dictionary. &#34;&#34;&#34;
        for k, v in d.items():
            # Note that the condition below prevents the _count property from
            # being added to the list over and over again.
            if k[:1] != &#34;_&#34;:
                s.append(k)
                if isinstance(v, dict) and v:
                    s = self.flattendict(v, s)
        return s

    def encodecategory(self,c):
        &#34;&#34;&#34; This helper function encodes any category name into a URL-friendly
        string, making sensible and human-readable substitutions. &#34;&#34;&#34;
        c = c.lower()
        c = c.replace(&#34; &#34;,&#34;-&#34;)
        c = c.replace(&#34;,&#34;,&#34;&#34;)
        c = c.replace(&#34;&#39;&#34;,&#34;&#34;)
        c = c.replace(&#34;&amp;&#34;,&#34;en&#34;)
        c = c.replace(&#34;ë&#34;,&#34;e&#34;)
        c = c.replace(&#34;=&#34;,&#34;-is-&#34;)
        c = c.replace(&#34;%&#34;,&#34;-procent-&#34;)
        c = c.replace(&#34;--&#34;,&#34;-&#34;)
        c = urllib.parse.quote(c)
        return c

    def prepproduct(self,p):
        &#34;&#34;&#34; This helper function flattens and rationalizes the values retrieved
        for a product block element. &#34;&#34;&#34;
        r = {}
        r[&#39;name&#39;] = p[&#39;name&#39;]
        r[&#39;price&#39;] = p[&#39;price&#39;][&#39;selling_price&#39;]
        r[&#39;price&#39;] = str(r[&#39;price&#39;])[0:-2]+&#34;,-&#34; if r[&#39;price&#39;] % 100 == 0 else str(r[&#39;price&#39;])[0:-2]+&#34;,&#34;+str(r[&#39;price&#39;])[-2:]
        if r[&#39;price&#39;][0:1] == &#34;,&#34;:
            r[&#39;price&#39;] = &#34;0&#34;+r[&#39;price&#39;]
        if p[&#39;properties&#39;][&#39;discount&#39;] is not None:
            r[&#39;discount&#39;] = p[&#39;properties&#39;][&#39;discount&#39;] 
        r[&#39;smallimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
        r[&#39;bigimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
        r[&#39;id&#39;] = p[&#39;_id&#39;]
        return r

    def shoppingcartcount(self):
        &#34;&#34;&#34; This function returns the number of items in the shopping cart. &#34;&#34;&#34;
        return sum(list(map(lambda x: x[1], session[&#39;shopping_cart&#39;])))

    &#34;&#34;&#34; ..:: Session and Templating Functions ::.. &#34;&#34;&#34;

    def checksession(self):
        &#34;&#34;&#34; This function sets certain generally used session variables when
        those have not yet been set. This executes before every request, but
        will most likely only make changes once. &#34;&#34;&#34;
        if (&#39;session_valid&#39; not in session) or (session[&#39;session_valid&#39;] != 1):
            session[&#39;shopping_cart&#39;] = []
            session[&#39;items_per_page&#39;] = self.paginationcounts[0]
            session[&#39;session_id&#39;] = self.database.sessions.find_one({})[&#39;buid&#39;][0]
            session[&#39;profile_id&#39;] = str(self.database.profiles.find_one({})[&#39;_id&#39;])
            session[&#39;session_valid&#39;] = 1

    def renderpackettemplate(self, template=&#34;homepage.html&#34;, packet={}):
        &#34;&#34;&#34; This helper function adds all generally important variables to the
        packet sent to the templating engine, then calling upon Flask to 
        perform the actual render. &#34;&#34;&#34;
        packet[&#39;categoryindex&#39;] = self.categoryindex
        packet[&#39;mainmenulist&#39;] = self.mainmenuitems
        packet[&#39;categories_encode&#39;] = self.catencode
        packet[&#39;categories_decode&#39;] = self.catdecode
        packet[&#39;paginationcounts&#39;] = self.paginationcounts
        packet[&#39;items_per_page&#39;] = session[&#39;items_per_page&#39;]
        packet[&#39;session_id&#39;] = session[&#39;session_id&#39;]
        packet[&#39;profile_id&#39;] = session[&#39;profile_id&#39;]
        packet[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
        packet[&#39;shopping_cart_count&#39;] = self.shoppingcartcount()
        return render_template(template, packet=packet)

    &#34;&#34;&#34; ..:: Recommendation Functions ::.. &#34;&#34;&#34;

    def recommendations(self, count):
        &#34;&#34;&#34; This function returns the recommendations from the provided page
        and context, by sending a request to the designated recommendation
        service. &#34;&#34;&#34;
        resp = requests.get(self.recseraddress+&#34;/&#34;+session[&#39;profile_id&#39;]+&#34;/&#34;+str(count))
        if resp.status_code == 200:
            recs = eval(resp.content.decode())
            queryfilter = {&#34;_id&#34;: {&#34;$in&#34;: recs}}
            querycursor = self.database.products.find(queryfilter, self.productfields)
            resultlist = list(map(self.prepproduct, list(querycursor)))
            return resultlist
        return []

    &#34;&#34;&#34; ..:: Full Page Endpoints ::.. &#34;&#34;&#34;

    def productpage(self, cat1=None, cat2=None, cat3=None, cat4=None, page=1):
        &#34;&#34;&#34; This function renders the product page template with the products it
        can retrieve from the database, based on the URL path provided. &#34;&#34;&#34;
        catlist = [cat1, cat2, cat3, cat4]
        queryfilter = {}
        nononescats = []
        for k, v in enumerate(catlist):
            if v is not None:
                queryfilter[self.catlevels[k]] = self.catdecode[v]
                nononescats.append(v)
        querycursor = self.database.products.find(queryfilter, self.productfields)
        prodcount = self.database.products.count_documents(queryfilter)
        skipindex = session[&#39;items_per_page&#39;]*(page-1)
        querycursor.skip(skipindex)
        querycursor.limit(session[&#39;items_per_page&#39;])
        prodlist = list(map(self.prepproduct, list(querycursor)))
        if len(nononescats) &gt; 1:
            pagepath = &#34;/producten/&#34;+(&#34;/&#34;.join(nononescats))+&#34;/&#34;
        else:
            pagepath = &#34;/producten/&#34;
        return self.renderpackettemplate(&#39;products.html&#39;, {&#39;products&#39;: prodlist, \
            &#39;productcount&#39;: prodcount, \
            &#39;pstart&#39;: skipindex + 1, \
            &#39;pend&#39;: skipindex + session[&#39;items_per_page&#39;] if session[&#39;items_per_page&#39;] &gt; 0 else prodcount, \
            &#39;prevpage&#39;: pagepath+str(page-1) if (page &gt; 1) else False, \
            &#39;nextpage&#39;: pagepath+str(page+1) if (session[&#39;items_per_page&#39;]*page &lt; prodcount) else False, \
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[0],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[0]\
            })

    def productdetail(self, productid):
        &#34;&#34;&#34; This function renders the product detail page based on the product
        id provided. &#34;&#34;&#34;
        product = self.database.products.find_one({&#34;_id&#34;:str(productid)})
        return self.renderpackettemplate(&#39;productdetail.html&#39;, {&#39;product&#39;:product,\
            &#39;prepproduct&#39;:self.prepproduct(product),\
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[1],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[1]})

    def shoppingcart(self):
        &#34;&#34;&#34; This function renders the shopping cart for the user.&#34;&#34;&#34;
        i = []
        for tup in session[&#39;shopping_cart&#39;]:
            product = self.prepproduct(self.database.products.find_one({&#34;_id&#34;:str(tup[0])}))
            product[&#34;itemcount&#34;] = tup[1]
            i.append(product)
        return self.renderpackettemplate(&#39;shoppingcart.html&#39;,{&#39;itemsincart&#39;:i,\
            &#39;r_products&#39;:self.recommendations(4), \
            &#39;r_type&#39;:list(self.recommendationtypes.keys())[2],\
            &#39;r_string&#39;:list(self.recommendationtypes.values())[2]})

    def categoryoverview(self):
        &#34;&#34;&#34; This subpage shows all top-level categories in its main menu. &#34;&#34;&#34;
        return self.renderpackettemplate(&#39;categoryoverview.html&#39;)

    &#34;&#34;&#34; ..:: Dynamic AJAX Endpoints ::.. &#34;&#34;&#34;

    def changeprofileid(self):
        &#34;&#34;&#34; This function checks whether the provided session ID actually exists
        and stores it in the session if it does. &#34;&#34;&#34;
        try:
            newprofileid = request.form.get(&#39;profile_id&#39;)
            profidexists = self.database.profiles.find_one({&#39;_id&#39;: ObjectId(newprofileid)})
            if profidexists:
                session[&#39;profile_id&#39;] = newprofileid
                return &#39;{&#34;success&#34;:true}&#39;
            return &#39;{&#34;success&#34;:false}&#39;
        except:
            return &#39;{&#34;success&#34;:false}&#39;

    def addtoshoppingcart(self):
        &#34;&#34;&#34; This function adds one to the shopping cart. &#34;&#34;&#34;
        productid = request.form.get(&#39;product_id&#39;)
        cartids = list(map(lambda x: x[0], session[&#39;shopping_cart&#39;]))
        if productid in cartids:
            ind = cartids.index(productid)
            session[&#39;shopping_cart&#39;][ind] = (session[&#39;shopping_cart&#39;][ind][0], session[&#39;shopping_cart&#39;][ind][1]+1)
        else:
            session[&#39;shopping_cart&#39;].append((productid, 1))
        session[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
        return &#39;{&#34;success&#34;:true, &#34;itemcount&#34;:&#39;+str(self.shoppingcartcount())+&#39;}&#39;

    def changepaginationcount(self):
        &#34;&#34;&#34; This function changes the number of items displayed on the provided 
        page. &#34;&#34;&#34;
        session[&#39;items_per_page&#39;] = int(request.form.get(&#39;items_per_page&#39;))
        # TODO: add method that returns the exact URL the user should be 
        # returned to, including offset
        return &#39;{&#34;success&#34;:true, &#34;refurl&#34;:&#34;&#39;+request.form.get(&#39;refurl&#39;)+&#39;&#34;}&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="huw.HUWebshop.app"><code class="name">var <span class="ident">app</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.catdecode"><code class="name">var <span class="ident">catdecode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.categoryindex"><code class="name">var <span class="ident">categoryindex</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.catencode"><code class="name">var <span class="ident">catencode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.catlevels"><code class="name">var <span class="ident">catlevels</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.client"><code class="name">var <span class="ident">client</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.database"><code class="name">var <span class="ident">database</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.dbstring"><code class="name">var <span class="ident">dbstring</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.envvals"><code class="name">var <span class="ident">envvals</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.mainmenucount"><code class="name">var <span class="ident">mainmenucount</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.mainmenuitems"><code class="name">var <span class="ident">mainmenuitems</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.paginationcounts"><code class="name">var <span class="ident">paginationcounts</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.productfields"><code class="name">var <span class="ident">productfields</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="huw.HUWebshop.recommendationtypes"><code class="name">var <span class="ident">recommendationtypes</span></code></dt>
<dd>
<section class="desc"><p>..:: Initialization and Category Index Functions ::..</p></section>
</dd>
<dt id="huw.HUWebshop.recseraddress"><code class="name">var <span class="ident">recseraddress</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="huw.HUWebshop.addtoshoppingcart"><code class="name flex">
<span>def <span class="ident">addtoshoppingcart</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function adds one to the shopping cart.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addtoshoppingcart(self):
    &#34;&#34;&#34; This function adds one to the shopping cart. &#34;&#34;&#34;
    productid = request.form.get(&#39;product_id&#39;)
    cartids = list(map(lambda x: x[0], session[&#39;shopping_cart&#39;]))
    if productid in cartids:
        ind = cartids.index(productid)
        session[&#39;shopping_cart&#39;][ind] = (session[&#39;shopping_cart&#39;][ind][0], session[&#39;shopping_cart&#39;][ind][1]+1)
    else:
        session[&#39;shopping_cart&#39;].append((productid, 1))
    session[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
    return &#39;{&#34;success&#34;:true, &#34;itemcount&#34;:&#39;+str(self.shoppingcartcount())+&#39;}&#39;</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.categoryoverview"><code class="name flex">
<span>def <span class="ident">categoryoverview</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This subpage shows all top-level categories in its main menu.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def categoryoverview(self):
    &#34;&#34;&#34; This subpage shows all top-level categories in its main menu. &#34;&#34;&#34;
    return self.renderpackettemplate(&#39;categoryoverview.html&#39;)</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.changepaginationcount"><code class="name flex">
<span>def <span class="ident">changepaginationcount</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function changes the number of items displayed on the provided
page.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def changepaginationcount(self):
    &#34;&#34;&#34; This function changes the number of items displayed on the provided 
    page. &#34;&#34;&#34;
    session[&#39;items_per_page&#39;] = int(request.form.get(&#39;items_per_page&#39;))
    # TODO: add method that returns the exact URL the user should be 
    # returned to, including offset
    return &#39;{&#34;success&#34;:true, &#34;refurl&#34;:&#34;&#39;+request.form.get(&#39;refurl&#39;)+&#39;&#34;}&#39;</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.changeprofileid"><code class="name flex">
<span>def <span class="ident">changeprofileid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function checks whether the provided session ID actually exists
and stores it in the session if it does.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def changeprofileid(self):
    &#34;&#34;&#34; This function checks whether the provided session ID actually exists
    and stores it in the session if it does. &#34;&#34;&#34;
    try:
        newprofileid = request.form.get(&#39;profile_id&#39;)
        profidexists = self.database.profiles.find_one({&#39;_id&#39;: ObjectId(newprofileid)})
        if profidexists:
            session[&#39;profile_id&#39;] = newprofileid
            return &#39;{&#34;success&#34;:true}&#39;
        return &#39;{&#34;success&#34;:false}&#39;
    except:
        return &#39;{&#34;success&#34;:false}&#39;</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.checksession"><code class="name flex">
<span>def <span class="ident">checksession</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function sets certain generally used session variables when
those have not yet been set. This executes before every request, but
will most likely only make changes once.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def checksession(self):
    &#34;&#34;&#34; This function sets certain generally used session variables when
    those have not yet been set. This executes before every request, but
    will most likely only make changes once. &#34;&#34;&#34;
    if (&#39;session_valid&#39; not in session) or (session[&#39;session_valid&#39;] != 1):
        session[&#39;shopping_cart&#39;] = []
        session[&#39;items_per_page&#39;] = self.paginationcounts[0]
        session[&#39;session_id&#39;] = self.database.sessions.find_one({})[&#39;buid&#39;][0]
        session[&#39;profile_id&#39;] = str(self.database.profiles.find_one({})[&#39;_id&#39;])
        session[&#39;session_valid&#39;] = 1</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.createcategoryindex"><code class="name flex">
<span>def <span class="ident">createcategoryindex</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Within this function, we compose a nested dictionary of all
categories that occur within the database's products collection, and
save it to the categoryindex collection.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createcategoryindex(self):
    &#34;&#34;&#34; Within this function, we compose a nested dictionary of all 
    categories that occur within the database&#39;s products collection, and 
    save it to the categoryindex collection. &#34;&#34;&#34;
    pcatentries = self.database.products.find({},self.catlevels)
    index = {}
    for entry in pcatentries:
        self.reccatindex(index, entry, 0, len(self.catlevels)-1)
    for k, v in index.items():
        self.reccatcount(k, v, 0, len(self.catlevels)-1)
    self.database.categoryindex.insert_one(index)</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.encodecategory"><code class="name flex">
<span>def <span class="ident">encodecategory</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<section class="desc"><p>This helper function encodes any category name into a URL-friendly
string, making sensible and human-readable substitutions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def encodecategory(self,c):
    &#34;&#34;&#34; This helper function encodes any category name into a URL-friendly
    string, making sensible and human-readable substitutions. &#34;&#34;&#34;
    c = c.lower()
    c = c.replace(&#34; &#34;,&#34;-&#34;)
    c = c.replace(&#34;,&#34;,&#34;&#34;)
    c = c.replace(&#34;&#39;&#34;,&#34;&#34;)
    c = c.replace(&#34;&amp;&#34;,&#34;en&#34;)
    c = c.replace(&#34;ë&#34;,&#34;e&#34;)
    c = c.replace(&#34;=&#34;,&#34;-is-&#34;)
    c = c.replace(&#34;%&#34;,&#34;-procent-&#34;)
    c = c.replace(&#34;--&#34;,&#34;-&#34;)
    c = urllib.parse.quote(c)
    return c</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.flattendict"><code class="name flex">
<span>def <span class="ident">flattendict</span></span>(<span>self, d, s=['Gezond & verzorging', 'Lichaamsverzorging', 'Deodorant', 'Bodylotion en bodymilk', 'Bad en douche', 'Handzeep en handgel', 'Zonnebrand en aftersun', 'Lipverzorging', 'Watten', 'Handcremes', 'Persoonlijke hygiene', 'Maandverband', 'Intiemverzorging', 'Tampons', 'Inlegkruisjes', 'Incontinentie', 'Mini reisverpakkingen', 'Mini deodorant en geuren', 'Mini bad en douche', 'Mini shampoo en conditioner', 'Mini olie en lotion', 'Mini haarstyling', 'Mini tandpasta', 'Mini scheerschuim en scheergel', 'Toilettassen', 'Haarverzorging', 'Conditioner', 'Shampoo', 'Haarstyling', 'Haarkuur en haarmasker', 'Haarkleuring', 'Kappersproducten', 'Haarserum', 'Mondverzorging', 'Mondwater & spray', 'Tandenborstels', 'Tandpasta', 'Tandenstokers, floss & ragers', 'Kunstgebitverzorging', 'Elektrische tandenborstels', 'Scheren & ontharen', 'Scheermesjes', 'Scheerschuim en scheergel', 'Ontharingscreme, wax en hars', 'Scheerapparaten', 'Gezichtsverzorging man', 'Scheren', 'Aftershave', 'Creme', 'Reiniging man', 'Gezichtsmasker man', 'Gezichtsverzorging vrouw', 'Dagcreme', 'Reiniging', 'Gezichtsmasker', 'Oogcreme en serum', 'Onzuivere huid & acne', 'Nachtcreme', 'Accessoires', 'Optiek', 'Lenzen', 'Lenzenvloeistof', 'Dames brillen', 'Leesbrillen', 'Heren brillen', 'Wondverzorging', 'Wondverzorging', 'Pleisters', 'Wondontsmetting', 'Sportverzorging', 'Bandages en windsels', 'EHBO', 'Seksualiteit', 'Glijmiddelen en seksspeeltjes', 'Condooms', "Vibrators en dildo's", 'Vitaminen en supplementen', 'Multivitaminen', 'Botten', 'Weerstand', 'Uiterlijk', 'Enkelvoudige vitaminen', 'Ontspanning en rust', 'Overige voedingssuplementen', 'Blaas', 'Kind', 'Gewrichten', 'Hart en visolie', 'Mineralen', 'Energie', 'Man', 'Zwangerschap', 'Natuurlijke gezondheid', 'Geneesmiddelen', 'Weerstand', 'Luchtwegen en verkoudheid', 'Spierwrijfmiddelen', 'Huidverzorging en koortslip', 'Pijnstillers', 'Spijsvertering', 'Stoppen met roken', 'Luizen', 'Reisziekte', 'Aambeien', 'Homeopathisch', 'Oor en mond', 'Vaginale schimmel', 'Allergieen', 'Afslanken', 'Supplementen', 'Maaltijdvervangers', 'Voetverzorging', 'Voetverzorging', 'Kalknagels', 'Voetschimmel', 'Voetdeodorant', 'Verzorgende voetcremes', 'Wratten', 'Eelt en harde huid', 'Sportvoeding', 'Sportdranken', 'Sportvoeding', 'Zwangerschap', 'Zwangerschapstest en ovulatietest', 'Zwangerschapsvitamines', 'Haaraccessoires', 'Haaraccessoires', 'Gehoorbescherming', 'Oordoppen', 'Wonen & vrije tijd', 'Outdoor en vrije tijd', 'Outdoor en vrije tijd', 'Sportartikelen', 'Woonaccessoires', 'Kaarsen', 'Woonaccessoires', 'Lampen', 'Feestartikelen', 'Feestartikelen', 'Seizoenen', 'Kerst', 'Vakantie', 'Carnaval', 'Halloween', 'Pasen', 'Valentijn', 'Tuinartikelen', 'Tuinartikelen', 'Boeken & tijdschriften', 'Boeken', 'Kaarten', 'Kantoor benodigdheden', 'Kantoor benodigdheden', 'Knutselen en hobby', 'Knutselen en hobby', 'Muziek', 'Muziek', 'Films', 'Dvd en blue-ray', 'Wonen', 'Meubels', 'Games', 'Bordspellen', 'Huishouden', 'Toilet en keuken', 'Toiletblokken', 'Luchtverfrissers', 'Toiletpapier en vochtige doekjes', 'Tissues en zakdoekjes', 'Keukenpapier', 'Toiletreinigers', 'Keuken artikelen', 'Wassen en schoonmaken', 'Schoonmaken', 'Afwasmiddel', 'Wasverzachter', 'Wasmiddel', 'Vaatwastabletten', 'Reiniging vaatwasser', 'Vlekkenverwijderaars', 'Overig huishoudelijk', 'Overige huishoudelijke artikelen', 'Huishoudelijk textiel', 'Insectenbestrijding', 'Textielverf', 'Dierverzorging', 'Kat', 'Overige dierverzorging', 'Hond', 'Elektronica & media', 'Elektronica & media', 'Batterijen', 'Beeld en geluid', 'Media', 'Tablets en computers', 'Verlichting', 'Elektronica accessoires', 'Persoonlijke verzorging', 'Cartridges', 'Foto en film', 'Huishoudelijke apparaten', 'Overige elektronika', 'Telefonie', 'Kleding & sieraden', 'Dames', 'Panties en sokken', 'Dames kleding', 'Dames ondergoed', 'Patty Brard Collectie', 'Dames accessoires', 'Dames nachtmode', 'Heren', 'Sokken', 'Heren ondergoed', 'Heren accessoires', 'Heren nachtmode', 'Kleding accessoires', 'Tassen', 'Koffers', 'Schoenen, slippers en sloffen', "Baby's en kinderen", 'Babykleding', 'Kinderkleding', 'Baby- en kinderaccessoires', 'Sieraden & bijoux', 'Sieraden & bijoux', 'Eten & drinken', 'Koude dranken', 'Overige dranken', 'Energy drank', 'Snacks en snoep', 'Snacks en snoep', 'Mondverfrissers', 'Chips', 'Koffie en thee', 'Koffie', 'Thee', 'Make-up & geuren', 'Make-up accessoires', 'Wattenschijfjes en wattenstaafjes', 'Nagellakremovers', 'Make-up remover & reiniging', 'Make-up accessoires', 'Kunstnagels', 'Geuren en geschenkset', 'Geschenksets', 'Damesgeuren', 'Herengeuren', 'Make-up', 'Foundation & concealer', 'Mascara', 'Wenkbrauwproducten', 'Highlighters en bronzers', 'Lipstick', 'Nagellak', 'Oogschaduw', 'Lipliner', 'Blush', 'Poeder', 'Lipgloss', 'Baby & kind', 'Luiers en verschonen', 'Luiers', 'Babydoekjes', 'Zwemluiers', 'Luierbroekjes en pyjamabroekjes', 'Babyverzorging', 'Baby huidverzorging', 'Babyhaartjes, bad en douche', 'Mama verzorging', 'Baby accessoires', 'Baby accessoires', 'Flessen en flessenspenen', 'Fopspenen', 'Baby speelgoed', 'Anti-lekbekers', 'Kinderbestek', 'Speelgoed', 'Speelgoed', 'Babyvoeding', 'Flesvoeding', 'Opruiming', 'Black Friday', 'Cadeau ideeën', 'Cadeau ideeën mannen', 'Cadeau ideeën kinderen', 'op=opruiming', '50% korting', 'Nieuw', 'Extra Deals', 'Folder artikelen'])</span>
</code></dt>
<dd>
<section class="desc"><p>This helper function provides a list of all keys that exist within a
nested dictionary.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flattendict(self,d,s=[]):
    &#34;&#34;&#34; This helper function provides a list of all keys that exist within a
    nested dictionary. &#34;&#34;&#34;
    for k, v in d.items():
        # Note that the condition below prevents the _count property from
        # being added to the list over and over again.
        if k[:1] != &#34;_&#34;:
            s.append(k)
            if isinstance(v, dict) and v:
                s = self.flattendict(v, s)
    return s</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.prepproduct"><code class="name flex">
<span>def <span class="ident">prepproduct</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<section class="desc"><p>This helper function flattens and rationalizes the values retrieved
for a product block element.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def prepproduct(self,p):
    &#34;&#34;&#34; This helper function flattens and rationalizes the values retrieved
    for a product block element. &#34;&#34;&#34;
    r = {}
    r[&#39;name&#39;] = p[&#39;name&#39;]
    r[&#39;price&#39;] = p[&#39;price&#39;][&#39;selling_price&#39;]
    r[&#39;price&#39;] = str(r[&#39;price&#39;])[0:-2]+&#34;,-&#34; if r[&#39;price&#39;] % 100 == 0 else str(r[&#39;price&#39;])[0:-2]+&#34;,&#34;+str(r[&#39;price&#39;])[-2:]
    if r[&#39;price&#39;][0:1] == &#34;,&#34;:
        r[&#39;price&#39;] = &#34;0&#34;+r[&#39;price&#39;]
    if p[&#39;properties&#39;][&#39;discount&#39;] is not None:
        r[&#39;discount&#39;] = p[&#39;properties&#39;][&#39;discount&#39;] 
    r[&#39;smallimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
    r[&#39;bigimage&#39;] = &#34;&#34; # TODO: replace this with actual images!
    r[&#39;id&#39;] = p[&#39;_id&#39;]
    return r</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.productdetail"><code class="name flex">
<span>def <span class="ident">productdetail</span></span>(<span>self, productid)</span>
</code></dt>
<dd>
<section class="desc"><p>This function renders the product detail page based on the product
id provided.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def productdetail(self, productid):
    &#34;&#34;&#34; This function renders the product detail page based on the product
    id provided. &#34;&#34;&#34;
    product = self.database.products.find_one({&#34;_id&#34;:str(productid)})
    return self.renderpackettemplate(&#39;productdetail.html&#39;, {&#39;product&#39;:product,\
        &#39;prepproduct&#39;:self.prepproduct(product),\
        &#39;r_products&#39;:self.recommendations(4), \
        &#39;r_type&#39;:list(self.recommendationtypes.keys())[1],\
        &#39;r_string&#39;:list(self.recommendationtypes.values())[1]})</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.productpage"><code class="name flex">
<span>def <span class="ident">productpage</span></span>(<span>self, cat1=None, cat2=None, cat3=None, cat4=None, page=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This function renders the product page template with the products it
can retrieve from the database, based on the URL path provided.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def productpage(self, cat1=None, cat2=None, cat3=None, cat4=None, page=1):
    &#34;&#34;&#34; This function renders the product page template with the products it
    can retrieve from the database, based on the URL path provided. &#34;&#34;&#34;
    catlist = [cat1, cat2, cat3, cat4]
    queryfilter = {}
    nononescats = []
    for k, v in enumerate(catlist):
        if v is not None:
            queryfilter[self.catlevels[k]] = self.catdecode[v]
            nononescats.append(v)
    querycursor = self.database.products.find(queryfilter, self.productfields)
    prodcount = self.database.products.count_documents(queryfilter)
    skipindex = session[&#39;items_per_page&#39;]*(page-1)
    querycursor.skip(skipindex)
    querycursor.limit(session[&#39;items_per_page&#39;])
    prodlist = list(map(self.prepproduct, list(querycursor)))
    if len(nononescats) &gt; 1:
        pagepath = &#34;/producten/&#34;+(&#34;/&#34;.join(nononescats))+&#34;/&#34;
    else:
        pagepath = &#34;/producten/&#34;
    return self.renderpackettemplate(&#39;products.html&#39;, {&#39;products&#39;: prodlist, \
        &#39;productcount&#39;: prodcount, \
        &#39;pstart&#39;: skipindex + 1, \
        &#39;pend&#39;: skipindex + session[&#39;items_per_page&#39;] if session[&#39;items_per_page&#39;] &gt; 0 else prodcount, \
        &#39;prevpage&#39;: pagepath+str(page-1) if (page &gt; 1) else False, \
        &#39;nextpage&#39;: pagepath+str(page+1) if (session[&#39;items_per_page&#39;]*page &lt; prodcount) else False, \
        &#39;r_products&#39;:self.recommendations(4), \
        &#39;r_type&#39;:list(self.recommendationtypes.keys())[0],\
        &#39;r_string&#39;:list(self.recommendationtypes.values())[0]\
        })</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.reccatcount"><code class="name flex">
<span>def <span class="ident">reccatcount</span></span>(<span>self, k, v, l, m)</span>
</code></dt>
<dd>
<section class="desc"><p>This subfunction of createcategoryindex() adds the number of
documents associated with any (sub)category to its dictionary as the
_count property.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reccatcount(self,k,v,l,m):
    &#34;&#34;&#34; This subfunction of createcategoryindex() adds the number of 
    documents associated with any (sub)category to its dictionary as the
    _count property. &#34;&#34;&#34;
    if l &gt; m:
        return
    if isinstance(v, dict):
        for k2, v2 in v.items():
            self.reccatcount(k2, v2, l+1, m)
    if k[:1] != &#34;_&#34;:
        v[&#39;_count&#39;] = self.database.products.count_documents({self.catlevels[l]:k})</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.reccatindex"><code class="name flex">
<span>def <span class="ident">reccatindex</span></span>(<span>self, d, e, l, m)</span>
</code></dt>
<dd>
<section class="desc"><p>This subfunction of createcategoryindex() sets up the base structure
(tree) of the categories and subcategories, leaving leaves as empty
dicts.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reccatindex(self,d,e,l,m):
    &#34;&#34;&#34; This subfunction of createcategoryindex() sets up the base structure
    (tree) of the categories and subcategories, leaving leaves as empty 
    dicts.&#34;&#34;&#34;
    if l &gt; m:
        return
    t = self.catlevels[l]
    if t in e and e[t] is not None and type(e[t]) != list and e[t] not in d:
        d[e[t]] = {}
    if t in e and e[t] is not None and type(e[t]) != list and e[t] in d:
        self.reccatindex(d[e[t]],e,l+1,m)</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.recommendations"><code class="name flex">
<span>def <span class="ident">recommendations</span></span>(<span>self, count)</span>
</code></dt>
<dd>
<section class="desc"><p>This function returns the recommendations from the provided page
and context, by sending a request to the designated recommendation
service.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def recommendations(self, count):
    &#34;&#34;&#34; This function returns the recommendations from the provided page
    and context, by sending a request to the designated recommendation
    service. &#34;&#34;&#34;
    resp = requests.get(self.recseraddress+&#34;/&#34;+session[&#39;profile_id&#39;]+&#34;/&#34;+str(count))
    if resp.status_code == 200:
        recs = eval(resp.content.decode())
        queryfilter = {&#34;_id&#34;: {&#34;$in&#34;: recs}}
        querycursor = self.database.products.find(queryfilter, self.productfields)
        resultlist = list(map(self.prepproduct, list(querycursor)))
        return resultlist
    return []</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.renderpackettemplate"><code class="name flex">
<span>def <span class="ident">renderpackettemplate</span></span>(<span>self, template='homepage.html', packet={})</span>
</code></dt>
<dd>
<section class="desc"><p>This helper function adds all generally important variables to the
packet sent to the templating engine, then calling upon Flask to
perform the actual render.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def renderpackettemplate(self, template=&#34;homepage.html&#34;, packet={}):
    &#34;&#34;&#34; This helper function adds all generally important variables to the
    packet sent to the templating engine, then calling upon Flask to 
    perform the actual render. &#34;&#34;&#34;
    packet[&#39;categoryindex&#39;] = self.categoryindex
    packet[&#39;mainmenulist&#39;] = self.mainmenuitems
    packet[&#39;categories_encode&#39;] = self.catencode
    packet[&#39;categories_decode&#39;] = self.catdecode
    packet[&#39;paginationcounts&#39;] = self.paginationcounts
    packet[&#39;items_per_page&#39;] = session[&#39;items_per_page&#39;]
    packet[&#39;session_id&#39;] = session[&#39;session_id&#39;]
    packet[&#39;profile_id&#39;] = session[&#39;profile_id&#39;]
    packet[&#39;shopping_cart&#39;] = session[&#39;shopping_cart&#39;]
    packet[&#39;shopping_cart_count&#39;] = self.shoppingcartcount()
    return render_template(template, packet=packet)</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.shoppingcart"><code class="name flex">
<span>def <span class="ident">shoppingcart</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function renders the shopping cart for the user.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def shoppingcart(self):
    &#34;&#34;&#34; This function renders the shopping cart for the user.&#34;&#34;&#34;
    i = []
    for tup in session[&#39;shopping_cart&#39;]:
        product = self.prepproduct(self.database.products.find_one({&#34;_id&#34;:str(tup[0])}))
        product[&#34;itemcount&#34;] = tup[1]
        i.append(product)
    return self.renderpackettemplate(&#39;shoppingcart.html&#39;,{&#39;itemsincart&#39;:i,\
        &#39;r_products&#39;:self.recommendations(4), \
        &#39;r_type&#39;:list(self.recommendationtypes.keys())[2],\
        &#39;r_string&#39;:list(self.recommendationtypes.values())[2]})</code></pre>
</details>
</dd>
<dt id="huw.HUWebshop.shoppingcartcount"><code class="name flex">
<span>def <span class="ident">shoppingcartcount</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function returns the number of items in the shopping cart.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def shoppingcartcount(self):
    &#34;&#34;&#34; This function returns the number of items in the shopping cart. &#34;&#34;&#34;
    return sum(list(map(lambda x: x[1], session[&#39;shopping_cart&#39;])))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="huw.HUWebshop" href="#huw.HUWebshop">HUWebshop</a></code></h4>
<ul class="">
<li><code><a title="huw.HUWebshop.addtoshoppingcart" href="#huw.HUWebshop.addtoshoppingcart">addtoshoppingcart</a></code></li>
<li><code><a title="huw.HUWebshop.app" href="#huw.HUWebshop.app">app</a></code></li>
<li><code><a title="huw.HUWebshop.catdecode" href="#huw.HUWebshop.catdecode">catdecode</a></code></li>
<li><code><a title="huw.HUWebshop.categoryindex" href="#huw.HUWebshop.categoryindex">categoryindex</a></code></li>
<li><code><a title="huw.HUWebshop.categoryoverview" href="#huw.HUWebshop.categoryoverview">categoryoverview</a></code></li>
<li><code><a title="huw.HUWebshop.catencode" href="#huw.HUWebshop.catencode">catencode</a></code></li>
<li><code><a title="huw.HUWebshop.catlevels" href="#huw.HUWebshop.catlevels">catlevels</a></code></li>
<li><code><a title="huw.HUWebshop.changepaginationcount" href="#huw.HUWebshop.changepaginationcount">changepaginationcount</a></code></li>
<li><code><a title="huw.HUWebshop.changeprofileid" href="#huw.HUWebshop.changeprofileid">changeprofileid</a></code></li>
<li><code><a title="huw.HUWebshop.checksession" href="#huw.HUWebshop.checksession">checksession</a></code></li>
<li><code><a title="huw.HUWebshop.client" href="#huw.HUWebshop.client">client</a></code></li>
<li><code><a title="huw.HUWebshop.createcategoryindex" href="#huw.HUWebshop.createcategoryindex">createcategoryindex</a></code></li>
<li><code><a title="huw.HUWebshop.database" href="#huw.HUWebshop.database">database</a></code></li>
<li><code><a title="huw.HUWebshop.dbstring" href="#huw.HUWebshop.dbstring">dbstring</a></code></li>
<li><code><a title="huw.HUWebshop.encodecategory" href="#huw.HUWebshop.encodecategory">encodecategory</a></code></li>
<li><code><a title="huw.HUWebshop.envvals" href="#huw.HUWebshop.envvals">envvals</a></code></li>
<li><code><a title="huw.HUWebshop.flattendict" href="#huw.HUWebshop.flattendict">flattendict</a></code></li>
<li><code><a title="huw.HUWebshop.mainmenucount" href="#huw.HUWebshop.mainmenucount">mainmenucount</a></code></li>
<li><code><a title="huw.HUWebshop.mainmenuitems" href="#huw.HUWebshop.mainmenuitems">mainmenuitems</a></code></li>
<li><code><a title="huw.HUWebshop.paginationcounts" href="#huw.HUWebshop.paginationcounts">paginationcounts</a></code></li>
<li><code><a title="huw.HUWebshop.prepproduct" href="#huw.HUWebshop.prepproduct">prepproduct</a></code></li>
<li><code><a title="huw.HUWebshop.productdetail" href="#huw.HUWebshop.productdetail">productdetail</a></code></li>
<li><code><a title="huw.HUWebshop.productfields" href="#huw.HUWebshop.productfields">productfields</a></code></li>
<li><code><a title="huw.HUWebshop.productpage" href="#huw.HUWebshop.productpage">productpage</a></code></li>
<li><code><a title="huw.HUWebshop.reccatcount" href="#huw.HUWebshop.reccatcount">reccatcount</a></code></li>
<li><code><a title="huw.HUWebshop.reccatindex" href="#huw.HUWebshop.reccatindex">reccatindex</a></code></li>
<li><code><a title="huw.HUWebshop.recommendations" href="#huw.HUWebshop.recommendations">recommendations</a></code></li>
<li><code><a title="huw.HUWebshop.recommendationtypes" href="#huw.HUWebshop.recommendationtypes">recommendationtypes</a></code></li>
<li><code><a title="huw.HUWebshop.recseraddress" href="#huw.HUWebshop.recseraddress">recseraddress</a></code></li>
<li><code><a title="huw.HUWebshop.renderpackettemplate" href="#huw.HUWebshop.renderpackettemplate">renderpackettemplate</a></code></li>
<li><code><a title="huw.HUWebshop.shoppingcart" href="#huw.HUWebshop.shoppingcart">shoppingcart</a></code></li>
<li><code><a title="huw.HUWebshop.shoppingcartcount" href="#huw.HUWebshop.shoppingcartcount">shoppingcartcount</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>